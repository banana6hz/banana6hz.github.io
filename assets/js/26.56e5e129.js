(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{381:function(t,a,v){"use strict";v.r(a);var s=v(33),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"js事件循环机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js事件循环机制"}},[t._v("#")]),t._v(" js事件循环机制")]),t._v(" "),v("p",[t._v("哎一古，这个问题是面试的常客啊！让我来好好学习一下吧！！")]),t._v(" "),v("h3",{attrs:{id:"为什么javascript是单线程？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么javascript是单线程？"}},[t._v("#")]),t._v(" 为什么JavaScript是单线程？")]),t._v(" "),v("p",[t._v("单线程的意思就是说：一次只能干一件事儿。")]),t._v(" "),v("p",[t._v("那为什么要有这么没有效率的机制呢？来举个栗子🌰：\n如果不是单线程，那就可以一下干好多事儿啦。一个线程当我们在给某个DOM节点增加内容的时候，另一个线程正在删除这个DOM节点的内容，那要听谁的呢？这就乱套了！所以还是老老实实单线程，一件一件的完成。(虽然javascript是单线程，但是javascript中有同步和异步的概念，解决了js阻塞的问题。)")]),t._v(" "),v("h3",{attrs:{id:"同步和异步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步和异步"}},[t._v("#")]),t._v(" 同步和异步")]),t._v(" "),v("p",[v("strong",[t._v("同步")]),t._v("：同步就是说，如果在一个函数返回的时候，调用者就能够即时得到预期结果"),v("br"),t._v(" "),v("strong",[t._v("异步")]),t._v("：异步就是说，如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，像"),v("code",[t._v("setTimeout()")]),t._v("就是一个异步函数")]),t._v(" "),v("p",[t._v("JavaScript里面有两种任务："),v("br"),t._v(" "),v("strong",[t._v("同步任务")]),t._v("：在"),v("u",[t._v("主线程")]),t._v("(执行栈)排队执行的任务，只有前一个执行完毕，才能执行下一个任务"),v("br"),t._v(" "),v("strong",[t._v("异步任务")]),t._v("：在"),v("u",[t._v("任务队列")]),t._v('(先入先出),只有任务队列通知主线程，可以执行某个异步任务的时候，该任务才会进入主线程。 "任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。')]),t._v(" "),v("h3",{attrs:{id:"事件循环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),v("p",[t._v('线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）')])])}),[],!1,null,null,null);a.default=r.exports}}]);