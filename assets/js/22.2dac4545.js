(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{359:function(e,v,r){e.exports=r.p+"assets/img/life.b3251a15.jpg"},413:function(e,v,r){"use strict";r.r(v);var t=r(33),_=Object(t.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"vue生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[e._v("#")]),e._v(" Vue生命周期")]),e._v(" "),t("p",[e._v("Vue生命周期是面试中常遇到的题，并且之前在项目中，也因为不够理解Vue的生命周期，无法显示数据，希望能通过这次学习，真正理解到Vue的生命周期。")]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("先来一张官方的"),t("strong",[e._v("生命周期图")]),t("br"),e._v(" "),t("img",{attrs:{src:r(359),alt:"vue生命周期"}}),t("br"),e._v("\n首先顶部的 "),t("strong",[e._v("new Vue()")]),e._v(" 是Vue实例的初始化"),t("br"),e._v("\nVue所有的生命周期钩子自动绑定在this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。这是因为箭头函数绑定了父上下文，因此this与你期待的Vue实例不同。"),t("br"),e._v("\n1、beforeCreate"),t("br"),e._v("\n　　在实例初始化之后，数据观测和event/watcher时间配置之前被调用。")]),e._v(" "),t("p",[e._v("2、created"),t("br"),e._v("\n　　实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测，属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。开始创建VDOM，但是还没挂载，页面中的元素还没真正替换过来，页面还未渲染")]),e._v(" "),t("p",[e._v("3、beforeMount"),t("br"),e._v("\n　　在挂载开始之前被调用：相关的render函数首次被调用。"),t("br"),e._v("\n　　该钩子在服务器端渲染期间不被调用。")]),e._v(" "),t("p",[e._v("4、mounted"),t("br"),e._v("\n　　el被新创建的vm.$el替换，并挂在到实例上去之后调用该钩子函数。如果root实例挂载了一个文档内元素，当mounted被调用时vm.$el也在文档内。"),t("br"),e._v("\n　　该钩子在服务端渲染期间不被调用。页面已经渲染成功,执行到这一钩子函数，就表示vue实例被完整创建")]),e._v(" "),t("p",[e._v("5、beforeUpdate"),t("br"),e._v("\n　　数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。"),t("br"),e._v("\n　　你可以在这个钩子中进一步第更改状态，这不会触发附加的重渲染过程。"),t("br"),e._v("\n　　该钩子在服务端渲染期间不被调用。")]),e._v(" "),t("p",[e._v("6、updated"),t("br"),e._v("\n　　由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。"),t("br"),e._v("\n　　当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。"),t("br"),e._v("\n　　该钩子在服务端渲染期间不被调用。")]),e._v(" "),t("p",[e._v("7、activated"),t("br"),e._v("\n　　keep-alive组件激活时调用。"),t("br"),e._v("\n　　该钩子在服务器端渲染期间不被调用。")]),e._v(" "),t("p",[e._v("8、deactivated"),t("br"),e._v("\n　　keep-alive组件停用时调用。"),t("br"),e._v("\n　　该钩子在服务端渲染期间不被调用。")]),e._v(" "),t("p",[e._v("9、beforeDestroy 【类似于React生命周期的componentWillUnmount】"),t("br"),e._v("\n　　实例销毁之间调用。在这一步，实例仍然完全可用。"),t("br"),e._v("\n　　该钩子在服务端渲染期间不被调用。")]),e._v(" "),t("p",[e._v("10、destroyed"),t("br"),e._v("\n　　Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。")]),e._v(" "),t("p",[e._v("该钩子在服务端渲染不会被调用。")])])}),[],!1,null,null,null);v.default=_.exports}}]);