### 一、Array.from(new Set(arr.flat(Infinity))).sort((a, b) => { return a - b }) 它干了什么？
1. **arr.flat(Infinity)** 数组扁平化。所谓数组扁平化就是将数组中并不规则的多维数组去除维度，使之变为一维数组。  
`let newArray = arr.flat(depth)`   
**flat()** 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 
但使用 Infinity 作为深度，展开任意深度的嵌套数组
```js
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
console.log(arr.flat(Infinity)) 
//[1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]
```
2. Set()是ES6提供的新的数据结构，类似于数组，但不会有重复的值  
```js
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
var setArr = new Set(arr.flat(Infinity));
console.log(setArr);
```  
![set](../../.vuepress/imgs/interview/es6/set.jpg)  
3. **Array.from()**  
该函数用于将两类对象转化为真正的数组：类似数组的对象、可遍历对象(包括数据结构Set和Map)  
![array](../../.vuepress/imgs/interview/es6/array.jpg)  
如果参数是一个真正的数组，则会返回一个一模一样的数组

4. **Array.sort()** 方法用于对数组的元素进行排序。  
但是这个函数的排序有限，请看下面的栗子：
```js
var arr = [1, 72, 5, 22];
console.log(arr.sort()); //[1, 22, 5, 72]
```
由这个栗子可以看出，并未得出我们想要的结果，因为函数会先将元素转换为字符串,用字符串的首字符进行比较，如果第一个字符相同，继续比较第二个字符。   

如果真的要对数组进行严格的升序排列，可以使用**Array.sort((a, b) => { return a - b })**。  
那它是怎么实现的呢？可以来看看这个函数    
![sort](../../.vuepress/imgs/interview/es6/sort.png)   
- return a-b 这段代码：a指的是array[j] b指的是array[j+1] 即 <u>a 指的是前一个数，b指的是后一个数；</u>
- a-b>0时，也就是 第一个数比第二个数大,则在if语句中 fncompare()函数的结果为>0
所以if语句可以执行，两个数交换位置 a 数 换到 b 的位置 意思是 ：<u>大的数向后移动</u>

同理 可以知道 return b-a 就是倒序。

5. 最终结果：返回一个升序并且去重的一维数组
```js
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
console.log(Array.from(new Set(arr.flat(Infinity))).sort((a, b) => { return a - b }));
//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```
