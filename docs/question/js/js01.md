## :white_medium_square: 1. 作用域与作用域链

- 作用域：当一个变量被声明的时候，会形成它的作用域，变量可以在这个作用域里面被调用
- 作用域链：是一套对变量引用的法则

每个函数都有自己的执行环境，每个执行环境都有一个与之关联的变量对象，保存着该环境定义的变量和函数。

当代码在一个环境中执行时，会创建一个变量对象的作用域链，作用域链保证了对执行环境有权访问的所有变量和函数的有序访问。

作用域是一套规则，用于确定在何处以及如何查找变量。如果查找的目的是对变量赋值，那么就会进行 LHS 查询；如果查找的目的是获取变量的值，那就回进行 RHS 查询。

不成功的 RHS 引用会导致抛出 RefferenceError 异常  
不成功的 LHS 引用会导致隐式地创建一个全局变量(非严格模式下)

作用域链访问的顺序为：局部的变量对象 ➡ 外部环境的变量对象 ➡ 全局环境的变量对象  
<font color="#425fe">（作用域链只能向上搜索，不能向下搜索）</font>

某个执行环境中所有的代码执行完毕后，该环境就会被销毁，保存在其中的所有变量和函数定义也随之销毁。<font color="#425fe">（全局环境直到应用程序退出（如关闭网页）时才会被销毁）</font>

## :white_medium_square: 2. 闭包

<b>闭包的教科书解释</b>：就是一个有权访问另一个函数作用域中变量的函数。（没错，闭包就是个函数）

在一个闭包里，你可以拥有对内部变量的引用，和外部变量的引用，但是外部函数不能访问内部变量

生成闭包的常见方式就是在一个函数内部创建另一个函数，此时内部函数就是一个闭包函数，他可以访问外部函数中的变量。  
为什么可以访问：因为内部函数的作用域链中包含了外部函数的作用域。  
正常情况下，函数执行完毕后，局部活动对象就会被销毁，内存中仅保存了全局活动对象。  
但对于闭包来说，当外部函数执行完毕时，该外部函数的作用域链就会被销毁，但是因为内部函数的作用域链还在引用外部函数的活动对象，所以外部函数的活动地对象依然保留在内存中，直到闭包函数被销毁。

- 优点：可以长期保存一个变量，避免全局变量的污染，可以存在私有成员
- 缺点：大量使用闭包，会造成内存泄露，虽然一个变量没有使用了，但是它的内部函数还拥有对他的引用，所以不会被回收，就一直积压在内存里

闭包与变量：闭包只能取得包含函数中任何变量的最后一个值

```js
for (var i = 0; i < 5; i++) {
  console.log("同步任务：", i); // 0 1 2 3 4
  setTimeout(() => {
    console.log("异步任务：", i); // 5 5 5 5 5
  }, 0);
} //输出全部是i的最后一次的值（5）
```

如上面的栗子，在同步任务中的输出很好理解。但是 setTimeout 是个异步任务，所以会把 for 循环走完之后才输出，这时候 i 已经累加到 5 了，而 setTimeout 输出的 i 是同一个 i,所以会连续输出 5 个 5

如何达到循环输出不一样的值呢？

- 使用 let

```js
for (let i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i); // 0 1 2 3 4
  }, 0);
}
```

- 使用立即执行函数

```js
for (var i = 0; i < 5; i++) {
  (function (j) {
    setTimeout(() => {
      console.log(j); // 0 1 2 3 4
    });
  })(i);
}
```

<b>闭包的应用</b>

- 返回一个函数

```js
function f1() {
  var a = 2;
  function f2() {
    console.log(a); //2
  }
  return f2;
}
var x = f1();
x();
```

- 作为函数参数传递

```js
var a = 1;
function foo() {
  var a = 2;
  function baz() {
    console.log(a);
  }
  bar(baz);
}
function bar(fn) {
  // 这就是闭包
  fn();
}
// 输出2，而不是1
foo();
```

- 异步操作

```js
//定时器
setTimeout(function () {
  console.log(1); // 1s后打印出1
}, 1000);
```

- IIFE：立即执行函数

```js
var a = 1;
(function IIFE() {
  console.log(a); // 1
})();
```

## :white_medium_square: 3. 原型与原型链

在讲解原型之前，先来想学习一下创建对象的几种模式。
**1.工厂模式**

```js
function createPerson(name, age) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.sayName = function () {
    alert(this.name);
  };
  return o;
}
var person1 = new createPerson("nico", 18);
var person2 = new createPerson("banana", 22);
```

工厂模式可以创建多个相似的对象，但没有解决对象识别的问题(即怎样知道一个对象的类型)

**2.构造函数模式**

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayName = function () {
    alert(this.name);
  };
}
var person1 = new Person("nico", 18);
var person2 = new Person("banana", 22);
```

对比工厂模式，构造函数模式可以知道自己是由谁创建的

```js
console.log(person1 instanceof Object); //true
console.log(person1 instanceof Person); //true
console.log(person2 instanceof Object); //true
console.log(person2 instanceof Person); //true
```

但构造函数也有缺点，就是每个方法在每个实例上都要创建一次。
如 person1 和 person2 都有一个 sayName 函数，但两个方法不是一个 Function 的实例，不同实例上的不同函数是不相等的。

```js
alert(person1.sayName() == person2.sayName()); //false
```

创造两个完成同样任务的 Function 实例是没有必要的，还会导致了不同作用域链和标识符的解析。因此我们可以优化一下这个构造函数

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayName = sayName;
}
function sayName() {
  alert(this.name);
}
var person1 = new Person("nico", 18);
var person2 = new Person("banana", 22);
alert(person1.sayName() == person2.sayName()); //true
```

我们把 sayName()定义在构造函数外部，这样 person1,person2 就共享了全局环境定义的 sayName 函数的。但是问题又来了，全局环境中定义的函数只能被某个函数调用，而且要是有很多个方法怎么办，那不就要定义很多方法了。那我们再来看看原型模式。

**3.原型模式**
我们在创建的每一个函数都会创建一个 prototype 原型属性，这个属性是一个指针，指向一个原型对象。原型对象 prototype 里面有 constructor，指向构造函数本身。

![prototype](../../.vuepress/imgs/blog/js/prototype01.jpg)

先弄懂两个东西

- prototype：在规范里，prototype 被定义为：给其它对象提供共享属性的对象。它是构造函数都有的属性，表示被实例化出来的对象的原型是谁。
- _proto_：所有 JavaScript 对象（包括函数）都有的属性，表示某个对象的原型

```js
//首先要明白两个准则
Person.prototype.constructor == Person;
// **准则1：原型对象（即Person.prototype）的constructor指向构造函数本身**
person1.__proto__ == Person.prototype;
// **准则2：实例（即person1）的__proto__和原型对象指向同一个地方**
```

关于原型链：当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它**proto**隐式原型上查找，即它的构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的**proto**中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链

👉 再来看看这张经典图

![prototype](../../.vuepress/imgs/blog/js/prototype02.png)

```js
// 从上方 function Foo() 开始分析这一张经典之图
function Foo(){};
let f1 = new Foo();
let f2 = new Foo();
f1._proto_ = Foo.prototype;
Foo.prototype._proto_ = Object.prototype;
Object.prototype._proto_ = null;// 原型链到此停止

f1.prototype.constructor = Foo;
Foo._proto_ = Function.prototype;
Function.prototype._proto_ = Object.prototype;
Object.prototype._proto_ = null;// 原型链到此停止
// **此处注意Foo 和 Function的区别， Foo是 Function的实例**

// 从中间 Function Object()开始分析这一张经典之图
function Object(){};
let o1 = new Object();
let o2 = new Object();
o1._proto_ = Object.prototype;
Object.prototype._proto_ = null;
Object.prototype.constructor = Object;
Object._proto_ = Function.prototype;
Function.prototype._proto_ = Object.prototype;
Object.prototype._proto_ = null;

// 从下方 Function Function()开始分析这一张经典之图
Function Function();
Function._proto_ = Object.prototype;
Object.prototype._proto_ = null;
```

👉 来看看原型模式如何创建对象

```js
function Person() {}
Person.prototype.name = "nico";
Person.prototype.age = 18;
Person.prototype.sayName = function () {
  alert(this.name);
};
var person1 = new Person();
person1.sayName(); //nico
var person2 = new Person();
person2.sayName(); //nico
alert(person1.sayName() == person2.sayName()); //true
```

原型模式让我们每个实例都共享了一个 sayName 函数，但是同时也共享了其他属性。但实际应用中，这样我们就不能创建属性不同的实例了。

**4.组合使用构造模式与原型模式**

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}
Person.prototype = {
  constructor: Person,
  sayName: function () {
    console.log(this.name);
  },
};
var p1 = new Person("banana", 18);
var p2 = new Person("apple", 20);
p1.sayName();
p2.sayName();
```

原型与原型层层相链接的过程即为原型链。

原型、原型链的意思何在？原型对象的作用，是用来存放实例中共有的那部份属性、方法，可以大大减少内存消耗。
假如我们创建不同的中国人，他们有不同的名字，不同的年龄，但是他们有共同的肤色，共同的头发，肤色和头发就是实例们共有属性，可以通过原型去访问，而不用在每一个实例上都创建这些属性。

**5.动态原型模式**

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  if (typeof this.sayName != "function") {
    Person.prototype.sayName = function () {
      console.log(this.name);
    };
  }
}
```

只有在 sayName()不存在的时候才会创建

**原型链继承**
原型链继承的关键就是：子的原型等于父的实例

```js
function Father(name, age) {
  this.name = name;
  this.age = age;
}
Father.prototype.sayName = function () {
  console.log(this.name);
};
var f1 = new Father("banana", 18);
var Child = function () {};
Child.prototype = new Father("apple", 20); //子的原型等于父的实例
var c1 = new Child();
c1.sayName();
```

## :white_medium_square: 4. 执行上下文

执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。

执行环境：全局环境、局部环境、eval

因此在一个 JavaScript 程序中，必定会产生多个执行上下文。

每个执行上下文包括：变量对象(VO)、作用域链（ScopeChain)、this 指针

JavaScript 引擎会以堆栈的方式来处理它们，这个堆栈，我们称其为函数调用栈(call stack)。栈底永远都是全局（环境）上下文，而栈顶就是当前正在执行的上下文。

当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。

🌰 我们来看个栗子：

```js
var color = "blue";
function changeColor() {
  var anotherColor = "red";
  function swapColors() {
    var tempColor = anotherColor;
    anotherColor = color;
    color = tempColor;
  }
  swapColors();
}
changeColor();
```

我们用 ECStack 来表示处理执行上下文组的堆栈。

- 全局上下文入栈
- changeColor EC 入栈
- swapColors EC 入栈
- swapColors EC 出栈
- changeColor EC 出栈
  ![estrack01](../../.vuepress/imgs/blog/js/estrack01.png)

通常情况下，全局上下文在浏览器窗口关闭后出栈。

<u>注意：函数中，遇到 return 能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。</u>

🌰 再来看个栗子：

```js
function f1() {
  var n = 18;
  function f2() {
    alert(n);
  }
  return f2;
}
var result = f1();
result(); // 18
```

因为 f1 中的函数 f2 在 f1 的可执行代码中，并没有被调用执行，因此执行 f1 时，f2 不会创建新的上下文，而直到 result 执行时，才创建了一个新的。具体演变过程如下。

![estrack02](../../.vuepress/imgs/blog/js/estrack02.png)

🌰 再来看个栗子：

```js
console.log("global begin: " + i); // ?
var i = 1;
foo(1);
function foo(i) {
  if (i == 4) {
    return;
  }
  console.log("foo() begin: " + i); // ?
  foo(i + 1);
  console.log("foo() end: " + i); // ?
}
console.log("global end: " + i); // ?
```

这个栗子的堆栈如图：

![estrack03](../../.vuepress/imgs/blog/js/estrack03.jpg)

所以这个栗子的输出结果依次为：undefined、1、2、3、3、2、1、1

## :white_medium_square: 5. this 的指向

JS 中的 this 在不同的情况下，它会指向不同的对象,这主要取决于函数的调用方式。

- 在全局上下文中，this 指的是 window
- 如果是构造函数 New 出来的新对象，this 指向这个新对象
- 由上下文的对象调用，则指向上下文对象
- 由 call 或 apply、bind 调用：绑定到指定的对象
- 所有的箭头函数都没有自己的 this，都指向外层。

在 JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法。这三个方法的主要作用是改变函数中的 this 指向。

**call()**
call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数  
`fun.call(thisArg, arg1, arg2, ...)`

- thisArg

  - 不传，或者传入 null、undefined，函数中的 this 指向 window 对象
  - 传递另一个函数的函数名，函数中的 this 指向这个函数的引用
  - 传递字符串、数值或布尔值等基础类型值，那函数中的 this 指向相应的包装对象(String、Number、Boolean)
  - 传递一个对象，函数中的 this 指向这个对象

  ```js
  function a() {
    console.log(this);
  }
  function b() {}
  var c = { name: "banana" };

  a.call(); //window
  a.call(null); //window
  a.call(undefined); //window
  a.call(1); //Number
  a.call(""); //String
  a.call(true); //Boolean
  a.call(b); //function b(){}
  a.call(c); //Object
  ```

  再来看看

  ```js
  function eat(x, y) {
    console.log(x + y);
  }
  function drink(x, y) {
    console.log(x - y);
  }
  eat.call(drink, 3, 2); //5
  ```

  在这个栗子中，drink 函数的 this 指向 eat 的引用，所以 eat 替换了 drink:eat.call(drink,3,2) == eat(3,2)  
   再来看看这个栗子

  ```js
  function Animal() {
    this.name = "animal";
    this.showName = function () {
      console.log(this.name);
    };
  }
  function Dog() {
    this.name = "dog";
  }
  var animal = new Animal();
  var dog = new Dog();
  animal.showName.call(dog);
  ```

  在这个栗子中，this 是指向 Dog 的,相当于把 showName 放到 Dog 上执行。

**apply**  
apply() 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数。  
`apply([thisObj[,argArray]])`
如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError

call 和 apply 的区别
对于 apply、call 两者而言，作用完全一样，不同的是接受参数的方式，请看下面的栗子

```js
function class1(args1, args2) {
  this.name = function () {
    console.log(args, args);
  };
}
function class2() {
  var args1 = "1";
  var args2 = "2";
  class1.call(this, args1, args2);
  /*或*/
  class1.apply(this, [args1, args2]);
}
var c = new class2();
c.name();
```

对的就是这样，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。  
所以当你的参数是确定的，一般推荐使用 call;如果参数不确定，那一般使用 apply,再把参数 push 进去。

**bind()**
MDN 的解释是：bind()方法会创建一个新函数，称为绑定函数。  
`function.bind(thisArg, arg1, arg2, ...)`  
当调用这个绑定函数时，绑定函数会以传入的第一个参数作为 this，第二个参数以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数调用原函数。(讲的啥？？)

```js
var bar = function () {
  console.log(this.x);
};
var foo = {
  x: 3,
};
bar();
var func = bar.bind(foo);
func(); //等价于bar.bind(foo)()
//undefined
//3
```

bind()与前两者的区别是，bind：不立即执行。而 apply、call 立即执行。

## 浅拷贝和深拷贝

- 浅拷贝：只能拷贝对象的第一层属性，当对象的属性是多层的时候，除了第一层属性，其他都只是拷贝了原对象引用地址
  - 普通对象浅拷贝方法：`newObj = {...oldObj}`, `newObj = Object.asign(oldObj)`
  - 数组对象浅拷贝方法： `newArray = [].concat(oldArray)`, `newArray = oldArray.slice(0, oldArray.length)`

```js
const obj1 = {
  a: 18,
  b: {
    b1: 1,
    b2: 2,
  },
};
const obj2 = { ...obj1 };
// 1. 修改原对象的第一层属性a
obj1.a = 20;
// 新对象的属性a没有发生改变
console.log(obj2.a); // 18
// 2. 修改原对象的第二层属性b.b1
obj1.b.b1 = 11;
// 新对象的第二层属性b.b1也会跟着改变
console.log(obj2.b.b1); // 11
// 反过来也一样
// 3. 新对象的第二层属性b.b2
obj2.b.b2 = 22;
// 原对象的第二层属性b.b2也会跟着改变
console.log(obj1.b.b2); // 22

// 第2和第3点的发生都是因为他们的对象引用的是同一个地址

// 来看看数组的
let oldArr = [1, 2, [3, 4]];
let newArr = [].concat(oldArr);
oldArr[2][0] = 8;
console.log(newArr[2][0]); // 8
```

> ...运算符和 Object.asign 在遇到 undefined 时会忽略。Array.concat()和 Array.slice 在遇到 undefined 时会变成 null

- 深拷贝: 可以拷贝对象的多层属性

  - `JSON.parse(JSON.stringify(oldObj))`

    1. 简单数据的拷贝：修改原数据的深层属性，新数据的深层属性不会发生改变

    ```js
    let oldObj = {
      a: 18,
      b: {
        b1: 1,
      },
    };
    let newObj = JSON.parse(JSON.stringify(oldObj));
    // 修改原数据的二层属性
    oldObj.b.b1 = 11;
    // 新数据的二层属性没有发生变化
    console.log(newObj.b.b1); // 1
    ```

    2. 属性有函数时：函数会丢失

    ```js
    let oldObj = {
      a: 18,
      sayHi: function () {
        console.log("Hi~");
      },
    };
    let newObj = JSON.parse(JSON.stringify(oldObj));
    // sayHi()丢失
    console.log(newObj); // {"a":18}
    ```

    3. 属性有 undefined 的值时：会忽略

    ```js
    let oldObj = {
      a: 18,
      b: undefined,
    };
    let newObj = JSON.parse(JSON.stringify(oldObj));
    // b丢失
    console.log(newObj); // {"a":18}
    ```

    4. 属性有 symbol 的值时：会忽略

    ```js
    let oldObj = {
      a: 18,
      sex: Symbol("male"),
    };
    let newObj = JSON.parse(JSON.stringify(oldObj));
    // sex丢失
    console.log(newObj); // {"a":18}
    ```

    5. 属性有 Date 的值时：会把日期格式转为字符串

    ```js
    let oldObj = {
      a: 18,
      date: new Date(),
    };
    let newObj = JSON.parse(JSON.stringify(oldObj));
    console.log(typeof oldObj.date); // object
    console.log(typeof newObj.date); // string
    ```

    6. 属性有构造函数的生成的对象: 该对象的 constructor 会丢失

    ```js
    function Person(name) {
      this.name = name;
    }
    let oldObj = {
      a: 18,
      p1: new Person("banana"),
    };
    let newObj = JSON.parse(JSON.stringify(oldObj));
    console.log(oldObj.p1.__proto__.constructor === Person); // true
    console.log(newObj.p1.__proto__.constructor === Person); // false
    console.log(newObj.p1.__proto__.constructor === Object); // true
    ```

    7. 属性有有循环引用对象：引用失败

    ```js
    let oldObj = {
      a: 18,
      b: {
        c: 3,
      },
    };
    let newObj = JSON.parse(JSON.stringify(oldObj));
    // 给原对象添加一个循环引用的对象
    oldObj.d = oldObj;
    // 新对象没有这个d
    console.log(newObj); // 报错
    ```

    8.NaN、Infinity 和-Infinity，则序列化后会变成 null

## 箭头函数的作用

## 如何避免地狱回掉

## sass 特性

## 组件 component 如何使用到父级页面的样式

## 优化前端性能总结

## 如何解决地狱回调

## ES5 和 ES6 的区别

## 小程序打开页面的数量限制是多少

10 个。在微信小程序中打开的页面不能超过 10 个,达到 10 个页面后,就不能再打开新的页面。

## npm i --save 和 npm i --save -dev 的区别

- 🍇 npm i --save：会把依赖安装到 package.json 中 dependencies 字段下，用于安装项目<font color="#f34134">运行时需要</font>的依赖，eg🥚：vue、JQuery
- 🍇 npm i --save -dev：会把依赖安装到 package.json 中 devDependencies 字段下，安装的依赖在项目运行的时候不需要，<font color="#f34134">只是开发的时候需要</font>，eg🥚：babel

## 离开了页面怎么访问原页面的数据

- 离开了页面，返回时还能获取该页面的数据 =》 keep-alive
- 离开了页面，让下一个页面还能访问上一个页面的数据 =》 用 vuex 存起来

## typeof null 的结果是 object,那 null 是对象吗？

答案：不是
解析：这是一个历史悠久的 bug,在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用的是低位存储变量的类型信息，000 开头的表示对象，而 null 代表是全零，所以才会出现 object 这个错误的结果

## var、let 以及 const 的区别？

- `var`在全局作用域下声明的变量会被挂载到 window 对象上，`let`、`const`不会

```js
var varValue = 1;
let letValue = 2;
const constValue = 3;
console.log(window.varValue, window.letValue, window.constValue);
// 1 undefined undefined
```

- `var`存在变量提升,被提升到作用域顶部，`let`、`const`不会

```js
function sayHi() {
  //var name;//伪代码,声明被提升了
  console.log(name); //undefined
  console.log(age); //age is not defined
  console.log(like); //like is not defined
  var name = "Banana";
  let age = 21;
  const like = 935;
}
sayHi();
```

- **暂时性死区(TDZ)**：变量在用`let`、`const`声明之前，他们是不可以访问的。如果在声明语句之前就访问变量，会抛出一个`ReferenceError`

```js
//TDZ开始
temp = "abc"; //ReferenceError
console.log(temp); //ReferenceError
let temp; //TDZ结束
```

- `let`、`const`声明的变量只在其代码块内有效

```js
{
  const constValue = 18;
  let letValue = 20;
  var varValue = 22;
}
constValue; //// Uncaught ReferenceError: constValue is not defined
letValue; //// Uncaught ReferenceError: letValue is not defined
22;
```

- `const`、`let`不允许在同一个作用域内重复声明一个变量，且 const 声明的是常量不可变(值是原始数据类型的不可改变，值是引用类型绑定的地址，地址不可变，但属性值能改变）。

```js
const constValue = 18;
const constValue = 20; //Identifier 'constValue' has already been declared
const constValue = 18;
constValue = 20; //Assignment to constant variable.
let a = 5;
a = 7; //可以的
let a = 8; //Identifier 'a' has already been declared
```

⚠️ 最后我们来看一道老朋友：

```js
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); //3,3,3
  }, 1000);
}
console.log("var定义的i", i); //3
```

在循环中，`console.log(i)`执行的都是同一个变量`i`,所以输出的是`i`最后的值。

那如果是`let`定义`i`又会是什么情况呢？

```js
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); //0,1,2
  }, 1000);
}
console.log("let定义的i", i); //undefined,因为let声明的i只在for循环代码块里有效
```

因为`for (let i = 0; i < 3; i++)`中，圆括号形成了一个隐藏的作用域，每次都会创建一个新变量。为了更好的理解可以看一下代码：

```js
// 伪代码
(let i = 0) {
    setTimeout(function timer() {
            console.log(i);
    }, 0);
}
(let i = 1) {
    setTimeout(function timer() {
        console.log(i);
    }, 0);
}
(let i = 2) {
    setTimeout(function timer() {
        console.log(i);
    }, 0);
};
```

变量的赋值可以分为三个阶段：

- 创建变量，在内存中开辟空间
- 初始化变量，将变量初始化为 undefined
- 真正赋值

关于 let、var 和 function：

- let 的「创建」过程被提升了，但是初始化没有提升。
- var 的「创建」和「初始化」都被提升了。
- function 的「创建」「初始化」和「赋值」都被提升了。

## js 的各种位置是怎样的

比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？

|    属性名    |                                         区别                                          |
| :----------: | :-----------------------------------------------------------------------------------: |
| clientHeight |    表示元素的**可视区域**的高度，不包含 border 和滚动条.样式的 height+上下 padding    |
| offsetHeight | 表示元素的**可视**的高度，包含了 border 和滚动条,还包含::before，::after 这样的伪元素 |
| scrollHeight |                 表示了**所有区域**的高度，包含了因为滚动被隐藏的部分                  |
|  offsetTop   |   当前元素顶部距离最近父元素(position:relative;)顶部的距离,和有没有滚动条没有关系。   |
|   scollTop   |  在有滚动条时，为元素顶部**被遮住部分**的高度。在没有滚动条时 scrollTop==0 恒成立。   |

## 什么是回调地狱

#### 什么是回调函数

回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。

```js
function getMessage(msg, callback) {
  setTimeout(function () {
    console.log(msg);
    callback();
  }, 2000);
}
function displayMessage() {
  console.log("Happy happy!");
}
getMessage("Hi banana", displayMessage);
//两秒后
//Hi Banana
//Happy happy
```

在上面这个栗子中，我们给函数 getMessage()传递了两个参数。第一个是 msg 变量，第二个是回调函数的引用（指针）。在 getMessage()完成后，将调用回调函数 displayMessage()。

#### 什么是回调地狱

当多个异步函数一个接着一个地执行，就会产生回调地狱。

#### 如何避免回调地狱

- 代码习惯
  - 将功能移开，保证简洁
  - 模块化
  - 处理每个回调中的每个错误
- Promise
- async-await

## 箭头函数和普通函数的区别

1. 箭头函数不能作为构造函数，不能使用 new。
2. 箭头函数没有原型属性。
3. 箭头函数的 this 指向其上下文的 this，没有办法改变其指向。普通函数的 this 指向调用它的对象。

<!--
### 7. Jquery函数
```js
(function(){})(jquery)和
!function(){}
```
---
### 8.insertAdjacentHTML() mr10417 -->

## Ajax 和 Axios 和 Fetch 的区别？

Ajax 是一种快速创建动态网页的技术，他的核心是 XHR(XMLHttpRequest)对象。多个请求之间如果有先后关系的话，就会出现回调地狱。

```js
var xhr = new XMLHttpRequest();
xhr.open("get", "banana.php", true); //三个参数：请求类型、请求路径、是否异步请求
xhr.send(null); //接受一个参数：要作为请求主体发送的数据。如果不需要，则传入null
if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
  alert(xhr.responseTest);
} else {
  alert("unsuccessful" + xhr.status);
}
```

jQuery Ajax 是对原生 XHR 的封装，使用起来更方便了。

```js
$ajax({
  methods: "post",
  url: "./banana/6hz",
  data: {
    name: "nico",
  },
  dataType: dataType,
  success: function () {},
  error: function () {},
});
```

Axios 是基于 Promise 上的，本质上也是对原生 XHR 的封装。不但可以在客户端使用，也可以在 nodejs 端使用。

```js
axios
  .post("./banana/6hz", {
    name: "banana",
    age: 18,
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

## 函数的节流和防抖是什么？

#### 防抖(debounce)

- 理解：在短时间内大量触发同一事件，防抖的含义在于：在某个时间期限（如 1000 毫秒）内，只会执行一次函数。
- 实现原理：设置一个 setTimeOut 函数，约定在某一段时间后再触发事件处理，每次触发事件都会重新设置计时器，直到在 X 毫秒内无二次操作。(延迟执行)
  ```js
  function debounce(fn, delay) {
    let timer = null; //借助闭包
    return function () {
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(fn, delay);
    };
  }
  function showTop() {
    var scrollTop =
      document.body.scrollTop || document.documentElement.scrollTop;
    console.log("滚动条位置：" + scrollTop);
  }
  window.onscroll = debounce(showTop, 1000);
  ```
  - 如果在 1s 内没有再次触发滚动事件，那么就执行函数
  - 如果在 1ms 内再次触发滚动事件，那么当前的计时取消，重新开始计时
- 应用：鼠标滚动事件

#### 节流：事件触发后每隔一段时间触发一次,可触发多次。

- 原理：设计一种类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活。
- 实现：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。

  ```js
  function throttle(func, wait) {
    let timeout = null;
    return function () {
      let context = this;
      let args = arguments;
      if (!timeout) {
        timeout = setTimeout(() => {
          timeout = null;
          func.apply(context, args);
        }, wait);
      }
    };
  }
  ```

- 应用：搜索框 input 事件，例如要支持输入实时搜索可以使用节流方案

#### 区别：

防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行。防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器。

## Promise 和 SetTimeout 有什么区别？

Promise 是微任务，setTimeout 是宏任务。微任务的优先级比宏任务高。

- [100](https://www.florin-pop.com/blog/built-100-projects-in-100-days/)

<!-- [参考链接](https://juejin.im/post/5d0644976fb9a07ed064b0ca) -->

## Json 对象和字符串互转

- Json.parse(String):接受一个 JSON 字符串并将其转换成一个 JavaScript 对象

```js
var b = '{"name":"banana","age":"18"}';
var bToObj = JSON.parse(b);
console.log(typeof bToObj); //object
```

- Json.stringify(obj):接受一个 JavaScript 对象并将其转换为一个 JSON 字符串

```js
var a = { name: "banana", age: "18" };
var aToStr = JSON.stringify(a);
console.log(typeof aToStr); //string
```

## 如何将一个字符串倒序

- 字符串转数组，反转数组，数组转字符串。

```js
var str = "http://localhost:8080/question/js/js01.html";
var strArr = str.split("");
var newStr = strArr.reverse();
console.log(newStr.join("")); //lmth.10sj/sj/noitseuq/0808:tsohlacol//:ptth
```

- 遍历字符串，再从末尾一个一个取出来放到新字符串

```js
var str = "http://localhost:8080/question/js/js01.html";
var newStr = "";
for (let i = 0; i < str.length; i++) {
  let s = str.charAt(str.length - 1 - i); //从末尾一个一个取出来
  newStr += s; //再一个个放到新字符串后面
}
```

- 字符串转数组，借助数组队列方法，数组转字符串。

```js
var str = "http://localhost:8080/question/js/js01.html";
var strArr = str.split("");
var newArr = [];
for (let i = strArr.length - 1; i >= 0; i--) {
  newArr.push(strArr[i]);
}
// 或者
// while(strArr.length>0){
//     newArr.push(strArr.pop())
// }
console.log(newArr.join(""));
```

## new 操作符具体干了什么？

**㊙：揭秘 new 背后的故事**

- 创建一个空对象，并把这个空对象的<font color="#f34134">原型</font>指向构造函数的原型对象
- 使用 apply 把构造函数的<font color="#f34134">作用域</font>赋值给这个新对象(因此 this 就指向了这个新对象)
- 执行构造函数的代码，为空对象增加新的<font color="#f34134">属性方法</font>
- 返回这个新对象

## 数组去重

⭐**set 与展开运算符**

```js
function unique(arr) {
  if (!Array.isArray(arr)) {
    console.log("type error!");
    return;
  }
  return [...new Set(arr)];
}
```

⭐**Array.from 与 Set**

```js
function unique(arr) {
  if (!Array.isArray(arr)) {
    console.log("type error!");
    return;
  }
  return Array.from(new Set(arr));
}
```

## onmousedown、onmouseup 以及 onclick 的执行顺序是怎么样的？

- **onmousedown**：当鼠标别被<font color="#f34134">点击时</font>触发
- **onmouseup**：当鼠标<font color="#f34134">释放</font>按钮时触发
- **onclick**：当完成<font color="#f34134">整个</font>鼠标点击事件时触发

```js
$(".test").click(function () {
  console.log("click");
});
$(".test").mouseup(function () {
  console.log("mouseup");
});
$(".test").mousedown(function () {
  console.log("mousedown");
});
//这里为了方便用了Jquery相应短的函数，输出顺序为mousedown、mouseup、click
```
