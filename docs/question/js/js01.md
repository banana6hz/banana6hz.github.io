## 下面代码的输出是什么？ 
### 1. 变量提升
```js
function sayHi() {
  console.log(name);
  console.log(age);
  var name = "Banana";
  let age = 21;
}
sayHi();
```  
<details><summary><b>Answer</b></summary>
<p>
在函数中，var关键字声明了name变量, 这意味着变量在创建阶段会被提升（JavaScript会在创建变量创建阶段为其分配内存空间），默认值为undefined，直到我们实际执行该变量的赋值语句，进入赋赋值阶段。 执行到console.log(name)语句的时候我们还没有为name变量赋值，所以它仍然保持undefined的值。
使用let关键字（和const）声明的变量也会存在变量提升，但与var不同的是初始化没有被提升。 在我们声明（初始化）它们之前，它们是不可访问的。 这被称为“暂时死区”。 当我们在声明变量之前尝试访问变量时，JavaScript会抛出一个ReferenceError。
</p>

🌰关于let的是否存在变量提升  
```js
let name = 'banana'
{
  console.log(name) // Uncaught ReferenceError: name is not defined
  let name = 'nana'
}
```  
let变量如果不存在变量提升，console.log(name)就会输出banana，结果却抛出了ReferenceError，那么这很好的说明了，let也存在变量提升，但是它存在一个“暂时死区”，在变量未初始化或赋值前不允许访问。  

变量的赋值可以分为三个阶段：  
- 创建变量，在内存中开辟空间
- 初始化变量，将变量初始化为undefined
- 真正赋值  

关于let、var和function：
- let 的「创建」过程被提升了，但是初始化没有提升。
- var 的「创建」和「初始化」都被提升了。
- function 的「创建」「初始化」和「赋值」都被提升了。

</details>

---

### 2. 执行上下文
```js
var b = 123;
if(true){
    function b () {}
    b = 333;
    console.log(b,'?',window.b)
}
console.log(b,window.b)
    
```  
<details><summary><b>?</b></summary>
<p>是啥呢🐷</p>
</details>

---
```js
function a() {}
  var a
  console.log(typeof a)
```

<details><summary><b>?</b></summary>
<p>结果为：function</br>
先执行变量提升, 再执行函数提升</p>
</details>

---
```js
if (!(b in window)) {
    var b = 1
  }
console.log(b)
```
<details><summary><b>?</b></summary>
<p>结果为：undefined</p>
</details>

---
```js
var c = 1
function c(c) {
  console.log(c)
  var c = 3
}                  //这儿的代码变量提升的时候早就执行好了
c(2)
```
<details><summary><b>?</b></summary>
<p>结果为会出错。先执行变量提升，后执行函数提升，最后执行变量赋值,即c = 1，此时typeof c结果为number</p>
</details>

```js
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(new Date, i);
    }, 1000);
}
console.log(new Date, i);
//如果想要分别在0-4秒输出一个5要怎么做呢
for (var i = 0; i < 5; i++) {
    (function(j) {  // j = i
        setTimeout(function() {
            console.log(new Date, j);
        }, 1000);
    })(i);
}
console.log(new Date, i);
//
var i=8;
for (var i=0;i<5;i++){
	setTimeout(function(){
	console.log(new Date,i)},i*1000)
}
console.log(new Date,i)//5
```


```js
var a = function a(){
	console.log(a===a)
}
a();//true

```
<details><summary><b>我是猪吗🐷为什么不确定</b></summary>
<p>//true</p>
</details>
```js
var arr = new Array(5).toString();
console.log(arr)
```
<details><summary><b>🐷</b></summary>
<p>//,,,,</p>
</details>

```js
var a = {
    b:18,
    c:{
        a:8,
        d:function(){
            console.log(this.a)
        }
    }
}
var one = a.c.d
console.log(one());
console.log(a.c.d());
```
<details><summary><b>🐷!第二次错了</b></summary>
<p>{b:18,c:{a:8,d:function(){console.log(this.a)}}}</p>
<p>8</p>
</details>

##  js的各种位置是怎样的
比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？ 

属性名|区别
:---:|:--:
clientHeight|表示元素的**可视区域**的高度，不包含border和滚动条.样式的height+上下padding
offsetHeight|表示元素的**可视**的高度，包含了border和滚动条,还包含::before，::after这样的伪元素
scrollHeight|表示了**所有区域**的高度，包含了因为滚动被隐藏的部分
offsetTop   |当前元素顶部距离最近父元素(position:relative;)顶部的距离,和有没有滚动条没有关系。
scollTop    | 在有滚动条时，为元素顶部**被遮住部分**的高度。在没有滚动条时scrollTop==0恒成立。

## 如何响应式设计viewport

viewport：是指网页的可视区域。
- width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，eg: width=device-width 表示页面宽度为设备的宽度）。
- height：和 width 相对应，指定高度。
- initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。eg:initial-scale=1.0代表初始页面不缩放。
- maximum-scale：允许用户缩放到的最大比例。
- minimum-scale：允许用户缩放到的最小比例。
- user-scalable：用户是否可以手动缩放。eg:user-scalable=0代表可以缩放

通常网页的写法都是
`<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />`  
1. 为什么有了`width=device-width`规定网页展示大小和设备大小一样了，还要加上`initial-scale=1.0`呢？  
因为iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病。

2. 如果width 和 initial-scale=1同时出现，并且还出现了冲突，如下：
`<meta name="viewport" content="width=400, initial-scale=1">`  

页面会以哪个为标准呢？  
会以数值大的那个为标准。如果initial-scale=1的数值为500，大于width的数字400，页面的展示宽度则以initial-scale=1为准；如果initial-scale=1的数值为370，小于width的400，页面的展示则以width=400为准。  

3. css中的1px并不等于设备的1px  
在桌面浏览器中，我们可以近似的理解为浏览器中css的1个像素对应着电脑屏幕的1个物理像素（但并不意味这是完全的对等，只是在此不讨论）  
在移动设备中，分辨率为320x480的iphone3的一个css像素确实是等于一个屏幕物理像素，。但随着技术不断的更新，出现了更高的分辨率以及更复杂的像素密度等级，设备上的一个css像素相当于多少个屏幕物理像素，因设备的不同而不同。  
---

## 什么是回调地狱
### 什么是回调函数  
回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
```js
function getMessage(msg, callback){
    setTimeout(function(){
        console.log(msg);
        callback();
    },2000);
}
function displayMessage(){
    console.log('Happy happy!');
}
getMessage('Hi banana',displayMessage)
//两秒后
//Hi Banana
//Happy happy
```
在上面这个栗子中，我们给函数getMessage()传递了两个参数。第一个是msg变量，第二个是回调函数的引用（指针）。在getMessage()完成后，将调用回调函数displayMessage()。

### 什么是回调地狱
当多个异步函数一个接着一个地执行，就会产生回调地狱。

### 如何避免回调地狱
- 代码习惯
   - 将功能移开，保证简洁
   - 模块化
   - 处理每个回调中的每个错误
- Promise
- async-await

## 箭头函数和普通函数的区别
1. 箭头函数不能作为构造函数，不能使用new。  
2. 箭头函数没有原型属性。  
3. 箭头函数的this指向其上下文的this，没有办法改变其指向。普通函数的this指向调用它的对象。  






<!-- 
### 7. Jquery函数  
```js
(function(){})(jquery)和  
!function(){}
```
---
### 8.insertAdjacentHTML() mr10417 -->



## Ajax和Axios和Fetch的区别？  
Ajax是一种快速创建动态网页的技术，他的核心是XHR(XMLHttpRequest)对象。多个请求之间如果有先后关系的话，就会出现回调地狱。
```js
var xhr = new XMLHttpRequest();
xhr.open('get','banana.php',true)//三个参数：请求类型、请求路径、是否异步请求
xhr.send(null)//接受一个参数：要作为请求主体发送的数据。如果不需要，则传入null
if(xhr.status >= 200 && xhr.status<300 || xhr.status == 304){
    alert(xhr.responseTest);
}else{
    alert('unsuccessful'+xhr.status)
}
```

jQuery Ajax是对原生XHR的封装，使用起来更方便了。
```js
$ajax({
    methods:'post',
    url:'./banana/6hz',
    data:{
        name:'nico'
    },
    dataType:dataType,
    success:function(){},
    error:function(){}
})
```

Axios是基于Promise上的，本质上也是对原生XHR的封装。不但可以在客户端使用，也可以在nodejs端使用。
```js
axios.post('./banana/6hz',{
    name:'banana',
    age:18
}).then(function(response){
    console.log(response);
}).catch(function(error){
    console.log(error);
})
```

## 函数的节流和防抖是什么？
### 防抖(debounce)  
- 理解：在短时间内大量触发同一事件，防抖的含义在于：在某个时间期限（如1000毫秒）内，只会执行一次函数。  
- 实现原理：设置一个setTimeOut函数，约定在某一段时间后再触发事件处理，每次触发事件都会重新设置计时器，直到在X毫秒内无二次操作。(延迟执行)
   ```js
   function debounce(fn,delay){
        let timer = null //借助闭包
        return function() {
            if(timer){
                clearTimeout(timer) 
            }
            timer = setTimeout(fn,delay)
        }
    }
    function showTop  () {
        var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    　　console.log('滚动条位置：' + scrollTop);
    }
    window.onscroll = debounce(showTop,1000) 
   ```
   - 如果在1s内没有再次触发滚动事件，那么就执行函数   
   - 如果在1ms内再次触发滚动事件，那么当前的计时取消，重新开始计时
- 应用：鼠标滚动事件

### 节流：事件触发后每隔一段时间触发一次,可触发多次。  
- 原理：设计一种类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活。  
- 实现：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。
   ```js
   function throttle(func, wait) {
        let timeout = null
        return function() {
            let context = this
            let args = arguments
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null
                    func.apply(context, args)
                }, wait)
            }

        }
    }
   ```  
- 应用：搜索框input事件，例如要支持输入实时搜索可以使用节流方案  
### 区别：
防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行。防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器。

### Promise和SetTimeout有什么区别？
Promise是微任务，setTimeout是宏任务。微任务的优先级比宏任务高。
### 

- [100](https://www.florin-pop.com/blog/built-100-projects-in-100-days/)


<!-- [参考链接](https://juejin.im/post/5d0644976fb9a07ed064b0ca) -->


## Json对象和字符串互转
- Json.parse(String):接受一个 JSON 字符串并将其转换成一个 JavaScript 对象
```js
var a={"name":"banana","age":"18"};
var aToStr=JSON.stringify(a);
console.log(typeof(aToStr)); //string
```
- Json.stringify(obj):接受一个 JavaScript 对象并将其转换为一个 JSON 字符串
```js
var b='{"name":"banana","age":"18"}';
var bToObj=JSON.parse(b);
console.log(typeof(bToObj));//object
```

## 