<!-- js 手写篇 -->

## 手写节流和防抖

- **节流**: 在一段时间内频繁触发某一事件，只执行一次

```vue
<template>
  <el-button @click="onClick">Throttle</el-button>
</template>
<script>
export default {
  onClick () {
    this.handleClick()
  }

  handleClick = this._throttle(() =>{
    console.log('_throttle')
  }, 1000)

  // 定时器版本：停止触发后执行
  _throttle (func, wait) {
    let timer = null
    return function () {
      let context = this
      let args = arguments
      if (!timer) {
        timer = setTimeout(() =>{
          func.apply(context, args)
          timer = null
        }, wait)
      }
    }
  }

  // 时间差版本： 第一次触发马上执行
  // 每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳
  throttle2(func, wait) {
    // 初始化事件开始的时间为0
    let prev = 0;
    return function () {
      // 获取当前的时间，使用+来转化为数字类型，方便后面做减法
      let now = Date.now();
      let context = this;
      let args = arguments;
      // 当前时间减去之前的时间，结果大于设定的间隔时间才会执行函数
      if (now - prev > wait) {
        func.apply(context, args);
        prev = now;
      }
    };
  }

  // 组合版： 实现了可以立即执行，停止触发后再执行一次的效果
  throttle3(func, wait) {
    let context, args, timer
    let pretime = 0
    let later = function () {
      pretime = +new Date()
      timer = null
      func.apply(context, args)
    }

    let throttled = function(){
        context = this;
        args = arguments;
        var now = +new Date();
        var remaining = wait - (now - pretime);
        // 剩余时间为负数表示下一次执行需要立即执行
        // remaining > wait在修改了系统时间的情况下可能发生
        if(remaining <= 0 || remaining > wait){
            // 如果有设置过定时器，清空并置为null
            if(timeout){
                clearTimeout(timeout)
                timeout = null;
            }
            pretime = now;
            func.apply(context,args);
        }else if(!timeout){
            // 需要在剩余时间后执行
            timeout = setTimeout(later,remaining);
        }
    };
    return throttled;
  }

  // 豪华升级版，可配置首次是否立即执行和结束后是否再执行一次
  // leading：false 表示禁用第一次执行
  // trailing: false 表示禁用停止触发的回调
  throttle4(func, wait, options) {
    let timeout, context, args, result;
    let pretime = 0;
    // options参数是可选的
    if (!options) options = {};

    let later = function() {
        pretime = options.leading === false ? 0 : +new Date();
        timeout = null;
        func.apply(context, args);
        if (!timeout) context = args = null;
    }

    let throttled = function() {
        context = this;
        args = arguments;
        let now = +new Date();
        // 如果禁用第一次执行，那么将上一次执行的时间于当前时间相等即可
        if (!pretime && options.leading === false) pretime = now;
        let remaining = wait - (now - pretime);
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            pretime = now;
            func.apply(context, args);
            if (!timeout) context = args = null;
            // 允许停止触发后执行回调函数，只有当traling为true时才会执行下面的代码
        } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
    };
    return throttled
  }
  // 1. 使用时间戳的方法，是可以达到第一次触发马上执行的效果，使用定时器的方法，可以达到停止触发后再执行一次的效果。
  // 2. 当设置了leading：true，trailing: false 允许第一次执行时,且不允许停止触发后再执行一次，当前时间pretime的初始值为0，接下来就一直使用时间戳的方法进行节流。
  // 3. 当设置了leading：true，trailing: true允许第一次执行，且允许停止触发后再执行一次，那么会在间隔时间大于等于wait的情况下，使用时间戳进行节流（达到第一次执行的效果），在间隔时间小于wait去触发时，设置定时器进行节流 （达到停止触发后再执行一次的效果），这就和我们的组合版相同。
  // 4. 当设置了leading：false，trailing: true禁止第一次执行，允许停止触发后再执行一次，当前时间的初始值为now（达到禁止第一次执行的效果），在使用定时器方法时，将pretime设置为0（pretime为0是判断是否为第一次执行的条件，如果同时满足pretime===0,leading===false,就会将pretime赋值为当前时间now）。
  // 5. 当设置了leading：false，trailing: false禁止第一次执行，禁止停止触发后再执行一次，当前时间pretime的初始值为now（达到禁止第一次执行的效果）同时不会使用定时器的方式。
}
</script>
```

- **防抖**：触发一次事件后，某一段时间内没有再触发，执行一次，如果在时间段内的某个时间又触发了该事件，则重新计时

## 手写深拷贝

## 手写 call 和 bind

## 数组去重
