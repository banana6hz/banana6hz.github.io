### 响应式: 进阶

### 1. shallowReactive 和 shallowRef

1. shallowReactive：只处理对象最外层属性的响应式（浅响应式）
2. shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理
3. 什么时候使用：
4. 如果有一个对象数据，结构比较深，但只是最外层属性会发生变化 ===>shallowReactive
5. 如果有一个对象数据，后续功能不会修改该对象的属性，而是生新的对象来替换 ===>shallowRef

```vue
<template>
  <h2>x的y的值：{{ x.y }}</h2>
  <button @click="x={y=88}">替换数据(有效)</button>
  <button @click="x.y++}">改变数据(无效)</button>
  <h2>姓名：{{ person.name }}</h2>
  <h2>年龄：{{ person.age }}</h2>
  <h2>薪资：{{ person.job.j1.salary }}</h2>
  <button @click="person.name += '~'">改变姓名</button>
  <button @click="person.age++">改变年龄</button>
  <button @click="person.job.j1.salary++">涨薪</button>
</template>

<script>
import {reactive, toRefs,   shallowReactive, shallowRef} from 'vue'
export default {
    name: 'Demo',
    setup() {
        //只考虑第一层数据的响应式
        let person = shallowReactive({
            name:'banana',
            age:18,
            job:{
                j1: {
                    salary: 100
                }
            }
        }),
        //只处理基本类型的响应式
        let x = shallowRef({
            y: 0
        })

        return {
            x,
            person,
            ...toRefs(person)
        }
    },
}
</script>
```

### 2.readonly 与 shallowReadonly

- readonly：让一个响应式数据变为只读的(深只读)
- shallowReadonly: 让一个响应式数据变为只读的(浅只读)
- 应用场景：不希望数据被修改时(被人传给你的)

```vue
<template>
  <h2>sum的值：{{ sum }}</h2>
  <button @click="sum++}">改变sum</button>
  <h2>姓名：{{ name }}</h2>
  <h2>年龄：{{ age }}</h2>
  <h2>薪资：{{ job.j1.salary }}</h2>
  <button @click="name += '~'">改变姓名</button>
  <button @click="age++">改变年龄</button>
  <button @click="job.j1.salary++">涨薪</button>
</template>

<script>
import { ref, reactive, toRefs, readonly, shallowReadonly } from "vue";
export default {
  name: "Demo",
  setup() {
    let sum = ref(0);
    let person = reactive({
        name: "banana",
        age: 18,
        job: {
          j1: {
            salary: 100,
          },
        },
      }),
      // person不能修改
      person = readonly(person);
    // person的第一层属性只读，不能修改，深层次属性可以修改
    person = shallowReadonly(person);
    sum = readonly(sum);
    sum = shallowReadonly(sum);

    return {
      sum,
      ...toRefs(person),
    };
  },
};
</script>
```

### 3. toRaw 与 markRaw

- toRaw:
  - 作用： 将一个由 reactive 生成的响应式对象转为普通对象
  - 应用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新
- markRaw
  - 作用： 标记一个对象，使其永远不会再成为响应式对象
  - 应用场景
    - 有些值不应该被设置为响应式，例如复杂的第三方类库等
    - 当渲染具有不可变数据的大列表时，跳过响应式转换可以提高性能

### 4. customRef

- 作用： 创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制
- 实现：创建一个防抖 ref，即只在最近一次 set 调用后的一段固定间隔后再调用

```vue
<template>
  <input v-model="text" />
  <h3>{{text}}</h3>
</template>
<script>
import { customRef } from 'vue'
export default {
    name: 'Demo',
    setup() {
        function useDebouncedRef(value, delay = 200) {
          let timeout
          return customRef((track, trigger) => {
            return {
              get() {
                track()//告诉vue这个value值是要被追踪的
                return value
              },
              set(newValue) {
                clearTimeout(timeout)
                timeout = setTimeout(() => {
                  value = newValue
                  trigger()// 重新更新页面
                }, delay)
              }
            }
          })
         }
         let text = myRef('hello', 500)
    }
}
```

### 5.
