## 浏览器关闭时请求接口

**背景**：业务需求是需要在浏览器关闭时请求接口记录日志  
**思路**：首先要知道怎么在浏览器关闭之前执行请求接口的操作,其次要确保接口的发送能完成

### beforeunload 和 unload

beforeunload：浏览器关闭前会执行的函数
unlaod：浏览器关闭时会执行的函数

尝试 1：通过 beforeunload 或者 unload 里面执行请求接口的操作
问题: 关闭标签页、关闭浏览器、刷新页面都会执行以上两个函数，无法区分

尝试 2：通过时间戳区分页面的刷新和关闭，分别在 beforeunload 和 unload 的事件记录时间戳，比较两者之间的时间差  
问题：无法确保时间差的值，不同类型的浏览器时间差不一样，比如火狐浏览器来说，刷新的时间差小于关闭的。而谷歌浏览器刷新的时间差是大于关闭的。不同电脑的浏览器也会不一样，比如我电脑可以用 120ms 作为分界点，但在其他同事电脑上就不行

尝试 3: 先把区分浏览器关闭和刷新放下，先实现用 HTTP 发送接口
问题：无法发送成功，服务器没接收到请求

尝试 4：用 navigator.sendBeacon()发送接口
问题：只可以发送 post 请求，并且可配置性弱

尝试 5：用 fetch 发送接口, 设置 keepalive 属性为 true  
问题：谷歌可以发送成功，火狐失败

尝试 6：谷歌采用 fetch 请求，火狐采用 http 的异步请求
结果：可以发送成功

因为刷新和关闭浏览器都会执行 beforeunload 和 unload 时间，但是刷新在这两个事件之后还会执行一个 load 事件
尝试 7：不管刷新还是关闭浏览器，都请求接口添加 log, 在刷新的 load 事件里删除刚刚添加的 log
问题：当只有一个窗口去关闭的时候，打开 F12 会发送请求，不打开不会发送

把 call 接口写在 unload
尝试 8: 把 call 接口写在 beforeunload
结果：成功

但是关闭接口之后再打开页面也会执行 load 事件，怎么区分是浏览器刷新之后的 load 事件还是重新打开一个新页面的 load 事件呢  
利用 sessionStorage，因为本系统是关闭页面就需要重新登录的，所以可以直接判断 sessionStorage 里面有没有某个字段，或者直接在 beforeunlaod 里面设置一个 sessionStorage,这样的话，浏览器刷新之后的 load 事件可以拿到这个 sessionStorage,而重新打开一个新页面的 load 事件是拿不到的
总结：

- 在 beforeunload 执行接口请求
- 区分谷歌和火狐浏览器
- 用 sessionStorage 区分是否需要在 load 里面执行删除
- 在 load 页面执行删除接口的请求

```js
mounted() {
        window.addEventListener('beforeunload', e => this.beforeunloadFn());
        window.addEventListener('load', e => this.loadFn());
    },
methods: {
  beforeunloadFn() {
      const loginData = JSON.parse(sessionStorage.getItem('vuex')).loginModule;
      loginData && loginData.akPost && (this.addLogoutLog({
          akPost: loginData.akPost,
          loginId: loginData.loginId,
          location: loginData.location,
          postType: loginData.postType,
          designation: loginData.designation,
          seqNo: loginData.seqNo,
      }));
  },
  loadFn() {
      const loginData = JSON.parse(sessionStorage.getItem('vuex')).loginModule;
      if (loginData && loginData.akPost) {
          this.deleteLogoutLog({
              akPost: loginData.akPost,
              loginId: loginData.loginId,
              location: loginData.location,
              postType: loginData.postType,
              designation: loginData.designation,
              seqNo: loginData.seqNo,
          });
      }
  },
  addLogoutLog(loginDataObject) {
      const isChrome = navigator.userAgent.indexOf('Chrome') !== -1;
      if (isChrome) {
          fetch('/api/addLog', {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json;charset=UTF-8',
              },
              body: JSON.stringify(loginDataObject),
              keepalive: true,
          });
      } else {
          const HttpRequest = new XMLHttpRequest();
          HttpRequest.open('post', '/api/addLog', false);
          HttpRequest.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
          HttpRequest.send(JSON.stringify(loginDataObject));
      }
  },
  deleteLogoutLog(loginDataObject) {
      const HttpRequest = new XMLHttpRequest();
      HttpRequest.open('post', '/api/deleteLog', false);
      HttpRequest.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
      HttpRequest.send(JSON.stringify(loginDataObject));
  },
},
```

参考文档

- https://juejin.cn/post/6844903790575878157
- https://juejin.cn/post/6844903871668551687
- https://juejin.cn/post/6992435294385471495

**业务背景**：需要在浏览器关闭时请求接口记录日志  
**实现思路**：首先要知道怎么在浏览器关闭之前执行请求接口的操作,其次要确保接口的发送能完成

### 浏览器关闭事件

- beforeUnload: 页面关闭/刷新会触发
- unload: 页面关闭/刷新会触发
  由此可见，如果在这两个函数中进行接口请求，那么刷新浏览器和关闭浏览器都会触发接口请求，显然和需求不符，刷新的时候是不需要请求接口的呢

- load：页面加载时触发  
  此时发现了另外一个事件，是在页面加载时会触发。刷新操作会重新加载页面，也就是会执行这个 load 事件，而关闭操作没有触发这个事件。所以，用户操作之后可以根据是否触发了 load 事件去区分用户进行的是刷新操作还是删除操作
- sessionStorage：会话存储  
  sessionStorage 只在当前会话有效，刷新操作是可以拿到 sessionStorage 的，而关闭之后在打开是没有这个 sessionStorage 的

- 总结：因为还是没有办法直接区分用户是关闭还是删除，必须要在重新加载页面或者重新打开一个页面才能知道用户是进行了什么操作。所以 beforeUnload 的时候都执行 addLog 操作，然后在 load 事件里，如果能拿到 sessionStorage 就去删除刚刚的 log
